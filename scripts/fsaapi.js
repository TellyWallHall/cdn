(function() { 'use strict'; // Check if File System Access API is supported const supportsFileSystemAccess = 'showSaveFilePicker' in window; if (!supportsFileSystemAccess) { console.log('File System Access API not supported, using fallback downloads'); return; } console.log('File System Access API detected - blob downloads will use native file picker'); // Store original createElement method const originalCreateElement = document.createElement; // Override createElement to intercept anchor creation document.createElement = function(tagName) { const element = originalCreateElement.call(this, tagName); if (tagName.toLowerCase() === 'a') { // Override the click method for anchor elements const originalClick = element.click; element.click = function() { if (this.href && this.href.startsWith('blob:') && this.download) { handleBlobDownload(this.href, this.download); return; } originalClick.call(this); }; } return element; }; // Also intercept direct blob downloads via URL.createObjectURL const originalCreateObjectURL = URL.createObjectURL; const blobUrlMap = new Map(); URL.createObjectURL = function(blob) { const url = originalCreateObjectURL.call(this, blob); blobUrlMap.set(url, blob); return url; }; // Handle blob download with File System Access API async function handleBlobDownload(blobUrl, filename) { try { let blob; // Get blob from our map or fetch it if (blobUrlMap.has(blobUrl)) { blob = blobUrlMap.get(blobUrl); } else { const response = await fetch(blobUrl); blob = await response.blob(); } // Determine file extension and MIME type const extension = filename.includes('.') ? filename.split('.').pop().toLowerCase() : 'txt'; const mimeType = blob.type || getMimeTypeFromExtension(extension); // Show save file picker const fileHandle = await window.showSaveFilePicker({ suggestedName: filename, types: [{ description: `${extension.toUpperCase()} files`, accept: { [mimeType]: [`.${extension}`] } }] }); // Write the file const writable = await fileHandle.createWritable(); await writable.write(blob); await writable.close(); console.log(`File saved successfully: ${filename}`); } catch (error) { if (error.name === 'AbortError') { console.log('File save cancelled by user'); } else { console.error('Error saving file:', error); // Fallback to regular download fallbackDownload(blobUrl, filename); } } } // Fallback to regular download function fallbackDownload(blobUrl, filename) { const a = originalCreateElement.call(document, 'a'); a.href = blobUrl; a.download = filename; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a); } // Helper function to get MIME type from extension function getMimeTypeFromExtension(ext) { const mimeTypes = { 'txt': 'text/plain', 'json': 'application/json', 'csv': 'text/csv', 'pdf': 'application/pdf', 'png': 'image/png', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'gif': 'image/gif', 'svg': 'image/svg+xml', 'zip': 'application/zip', 'xml': 'application/xml', 'html': 'text/html', 'css': 'text/css', 'js': 'application/javascript' }; return mimeTypes[ext] || 'application/octet-stream'; } // Intercept programmatic downloads window.downloadBlob = function(blob, filename) { if (supportsFileSystemAccess) { handleBlobDownload(URL.createObjectURL(blob), filename); } else { fallbackDownload(URL.createObjectURL(blob), filename); } }; })();